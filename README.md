## Индивидуальное домашнее задание № 2
### Дробышева Дарья Алексеевна, БПИ227
### Вариант № 35
 «Камень, ножницы, бумага» 1 — круговая система. N cтудентов, изнывающих от скуки на лекции по операционным системам решили организовать однокруговой турнир в игру «Камень, ножницы, бумага». Каждый с каждым при этом играет только один раз. За победу дается два очка, за ничью — одно, за поражение — ноль. Требуется создать многопроцессное приложение, моделирующее турнир. Каждый студент — отдельный процесс. Генерация камня, ножниц и бумаги в каждом процессе формируется случайно.


## Отчет

### Требования на 4-5 баллов
#### Запуск программы
```
gcc program.c -o program
./program <number_of_students> # указываем количество студентов в турнире
```
Например:
```
gcc program.c -o program
./program 5 # указываем количество студентов в турнире
```

#### Сценарий решаемой задачи
Каждый студент - отдельный процесс, который формируется с помощью fork() в коде. 

Каждый студент проходит по оппонентам, которые находятся по очереди за ним (первый - с 2 по n, второй - с 3 по n и тд) и с каждым играет в "камень ножницы бумага". Таким образом каждый с каждым сыграет ровно 1 раз. 


Игровой процесс описан функцией play_game(), в которой выбор каждого игрока формируется случайно. С помощью использования sleep() эмулируется длительность схватки в 1 секунду. 


Переход между участниками занимает 3 секунды, поэтому в main используется sleep(3).


Во время игр студенты накапливают баллы в соответствии с условием. После завершения игровых процессов выводятся результаты и победители турнира.

#### Использование семафоров и разделяемой памяти
Разделяемая память cоздается для хранения результатов игр. В данном случае используется структура Shared_Data, содержащая массив результатов для каждого студента.

Именованный семафор используется для обеспечения синхронизации доступа к разделяемой памяти. Семафор sem_mutex используется для захвата и освобождения доступа к разделяемой памяти при обновлении результатов игры. Это позволяет избежать гонок данных и гарантирует корректное обновление результатов при параллельной работе процессов.

#### Завершение программы

Программа завершается в соответствии с условием задачи по окончании "объявления" результатов, либо при принудительном прерывании с помощью Ctrl + C. В обоих случаях реализовано корректное завершение программы, удаление семафора и разделяемой памяти. 
```
sem_close(sem_mutex);
sem_unlink("/mutex_sem");
shm_unlink("/shared_memory");
```

#### Результаты работы
Можно посмотреть в файлах screen1.png, screen2.png

### Требования на 6-7 баллов
#### Запуск программы
```
gcc program.c -o program
./program <number_of_students> # указываем количество студентов в турнире
```
Например:
```
gcc program.c -o program
./program 5 # указываем количество студентов в турнире
```


#### Сценарий решаемой задачи
Каждый студент - отдельный процесс, который формируется с помощью fork() в коде. 

Каждый студент проходит по оппонентам, которые находятся по очереди за ним (первый - с 2 по n, второй - с 3 по n и тд) и с каждым играет в "камень ножницы бумага". Таким образом каждый с каждым сыграет ровно 1 раз. 

Игровой процесс описан функцией play_game(), в которой выбор каждого игрока формируется случайно. С помощью использования sleep() эмулируется длительность схватки в 1 секунду. 

Переход между участниками занимает 3 секунды, поэтому в main используется sleep(3).

Во время игр студенты накапливают баллы в соответствии с условием. После завершения игровых процессов выводятся результаты и победители турнира.

#### Использование семафоров и разделяемой памяти

Разделяемая память cоздается для хранения результатов игр. В данном случае используется структура Shared_Data, содержащая массив результатов для каждого студента.

НЕименованный семафор используется для обеспечения синхронизации доступа к разделяемой памяти. Семафор sem_mutex используется для захвата и освобождения доступа к разделяемой памяти при обновлении результатов игры. Это позволяет избежать гонок данных и гарантирует корректное обновление результатов при параллельной работе процессов.

#### Завершение программы

Программа завершается в соответствии с условием задачи по окончании "объявления" результатов, либо при принудительном прерывании с помощью Ctrl + C. В обоих случаях реализовано корректное завершение программы, удаление семафора и разделяемой памяти. 
```
sem_destroy(&sem_mutex);
shm_unlink("/shared_memory");
```

#### Результаты работы
Можно посмотреть в файле screen3.png.
